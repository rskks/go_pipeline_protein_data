```{r}
### R functions for pipeline. Run once

# FUNCTION FOR GO TERMS. Load into environment (run once)
`%||%` <- function(a, b) if (!is.null(a)) a else b

# ---------------------------
# Safe function to fetch GO terms for ONE protein
# ---------------------------
fetch_go_for_protein <- function(uniprot_id) {
  if (missing(uniprot_id) || !nzchar(uniprot_id)) stop("Please provide a valid UniProt ID.")

  base_url <- "https://www.ebi.ac.uk/QuickGO/services/annotation/search"
  all_results <- list()
  page <- 1L
  limit <- 200L

  # change API parameters HERE
  repeat {
    params <- list(
      geneProductId = uniprot_id,
      limit = limit,
      page = page,
      includeFields = paste(c("goName","name"), collapse = ",")
    )

    resp <- tryCatch(
      GET(base_url, query = params, add_headers(Accept = "application/json"), timeout(60)),
      error = function(e) stop("Request failed: ", e$message)
    )

    if (http_error(resp)) {
      stop(sprintf("QuickGO request failed: %s %s", status_code(resp), content(resp, "text", encoding = "UTF-8")))
    }

    parsed <- content(resp, as = "parsed", type = "application/json")
    results <- parsed$results

    if (is.null(results) || length(results) == 0) break

    # Remove empty items
    results <- results[map_lgl(results, ~ !is.null(.x) && length(.x) > 0)]
    if (length(results) > 0) all_results <- append(all_results, results)

    total <- parsed$pageInfo$total %||% 0
    per_page <- parsed$pageInfo$resultsPerPage %||% limit
    if (page * per_page >= total) break
    page <- page + 1L
  }

  if (length(all_results) == 0) {
    # No results: return 1-row tibble with empty lists
    return(tibble(
      UniProtID = uniprot_id,
      goIds = list(character(0)),
      goNames = list(NA_character_),
      ontology = list(NA_character_),
    ))
  }

  # Flatten JSON
  df <- fromJSON(toJSON(all_results, auto_unbox = TRUE), flatten = TRUE)

  # Ensure all columns exist
  if (!"goId" %in% names(df)) df$goId <- NA_character_
  if (!"goName" %in% names(df)) df$goName <- NA_character_
  if (!"goAspect" %in% names(df)) df$goAspect <- NA_character_

  # Coerce types and process synonyms safely
  df <- df %>%
    mutate(
      goId = as.character(goId),
      goName = as.character(goName),
      goAspect = as.character(goAspect),
    ) %>%
    select(goId, goName, goAspect) %>%
    distinct(goId, .keep_all = TRUE)  # Remove duplicate GO IDs

  # Combine results into lists aligned by index
  goIds <- df$goId
  goNames <- df$goName
  ontology <- df$goAspect

  # Return 1-row tibble with list-columns
  tibble(
    UniProtID = uniprot_id,
    goIds = list(goIds),
    goNames = list(goNames),
    ontology = list(ontology),
  )
}
```