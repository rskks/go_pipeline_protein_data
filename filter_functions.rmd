```{r}
# Functions for filtering by GO ID and GO Term (strict, non-strict) and combined methods. Load once
# -------------------------------
# GO ID filter
# -------------------------------
filter_proteins_by_go <- function(protein_df) {
  user_input <- readline(prompt = "Enter GO IDs to filter for (comma-separated, e.g., GO:0003677,GO:0008150): ")
  go_terms <- str_trim(unlist(str_split(user_input, ",")))
  if (length(go_terms) == 0) stop("No valid GO IDs entered.")
  
  n <- nrow(protein_df)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  filtered_flags <- map_lgl(seq_len(n), function(i) {
    setTxtProgressBar(pb, i)
    ids <- protein_df$goIds[[i]]
    if (is.null(ids) || length(ids) == 0) return(FALSE)
    any(ids %in% go_terms)
  })
  
  close(pb)
  filtered_df <- protein_df[filtered_flags, ]
  message(sprintf("Filtered %d proteins out of %d total.", nrow(filtered_df), nrow(protein_df)))
  return(filtered_df)
}

# -------------------------------
# GO name filter (contains/fuzzy)
# -------------------------------
filter_proteins_by_go_names <- function(protein_df) {
  user_input <- readline(prompt = "Enter GO term keywords to filter for (comma-separated, e.g., RNA binding, apoptosis): ")
  go_keywords <- str_trim(unlist(str_split(user_input, ",")))
  if (length(go_keywords) == 0) stop("No valid GO keywords entered.")
  
  n <- nrow(protein_df)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  filtered_flags <- map_lgl(seq_len(n), function(i) {
    setTxtProgressBar(pb, i)
    names <- protein_df$goNames[[i]]
    if (is.null(names) || length(names) == 0) return(FALSE)
    any(sapply(names, function(nm) any(str_detect(nm, regex(go_keywords, ignore_case = TRUE)))))
  })
  
  close(pb)
  filtered_df <- protein_df[filtered_flags, ]
  message(sprintf("Filtered %d proteins out of %d total.", nrow(filtered_df), nrow(protein_df)))
  return(filtered_df)
}

# -------------------------------
# Strict GO name filter (exact match)
# -------------------------------
filter_proteins_by_go_names_strict <- function(protein_df) {
  user_input <- readline(prompt = "Enter exact GO term names to filter for (comma-separated): ")
  go_exact <- str_trim(unlist(str_split(user_input, ",")))
  if (length(go_exact) == 0) stop("No valid GO keywords entered.")
  
  n <- nrow(protein_df)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  filtered_flags <- map_lgl(seq_len(n), function(i) {
    setTxtProgressBar(pb, i)
    names <- protein_df$goNames[[i]]
    if (is.null(names) || length(names) == 0) return(FALSE)
    any(names == go_exact) # changed from %in%
  })
  
  close(pb)
  filtered_df <- protein_df[filtered_flags, ]
  message(sprintf("Filtered %d proteins out of %d total.", nrow(filtered_df), nrow(protein_df)))
  return(filtered_df)
}

# -------------------------------
# Combined GO ID + GO name filter (non-strict / contains)
# -------------------------------
filter_proteins_by_go_combined <- function(protein_df) {
  user_go_ids <- readline(prompt = "Enter GO IDs to filter for (comma-separated, or leave blank to skip): ")
  go_ids <- if (nzchar(user_go_ids)) str_trim(unlist(str_split(user_go_ids, ","))) else character(0)
  
  user_go_names <- readline(prompt = "Enter GO term keywords to filter for (comma-separated, or leave blank to skip): ")
  go_names <- if (nzchar(user_go_names)) str_trim(unlist(str_split(user_go_names, ","))) else character(0)
  
  if (length(go_ids) == 0 && length(go_names) == 0) stop("No GO IDs or GO names entered.")
  
  n <- nrow(protein_df)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  filtered_flags <- map_lgl(seq_len(n), function(i) {
    setTxtProgressBar(pb, i)
    
    ids <- protein_df$goIds[[i]]
    names <- protein_df$goNames[[i]]
    
    match_id <- length(go_ids) > 0 && !is.null(ids) && any(ids %in% go_ids)
    match_name <- length(go_names) > 0 && !is.null(names) &&
                  any(sapply(names, function(nm) any(str_detect(nm, regex(go_names, ignore_case = TRUE)))))
    
    return(match_id || match_name) # OR function
  })
  
  close(pb)
  filtered_df <- protein_df[filtered_flags, ]
  message(sprintf("Filtered %d proteins out of %d total.", nrow(filtered_df), nrow(protein_df)))
  return(filtered_df)
}

# -------------------------------
# Combined GO ID + GO name filter (strict / exact)
# -------------------------------
filter_proteins_by_go_combined_strict <- function(protein_df) {
  user_go_ids <- readline(prompt = "Enter GO IDs to filter for (comma-separated, or leave blank to skip): ")
  go_ids <- if (nzchar(user_go_ids)) str_trim(unlist(str_split(user_go_ids, ","))) else character(0)
  
  user_go_names <- readline(prompt = "Enter exact GO term names to filter for (comma-separated, or leave blank to skip): ")
  go_names <- if (nzchar(user_go_names)) str_trim(unlist(str_split(user_go_names, ","))) else character(0)
  
  if (length(go_ids) == 0 && length(go_names) == 0) stop("No GO IDs or GO names entered.")
  
  n <- nrow(protein_df)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  filtered_flags <- map_lgl(seq_len(n), function(i) {
    setTxtProgressBar(pb, i)
    
    ids <- protein_df$goIds[[i]]
    names <- protein_df$goNames[[i]]
    
    match_id <- length(go_ids) > 0 && !is.null(ids) && any(ids %in% go_ids)
    match_name <- length(go_names) > 0 && !is.null(names) && any(names == go_names) # changed from %in%
    
    return(match_id || match_name) # OR function
  })
  
  close(pb)
  filtered_df <- protein_df[filtered_flags, ]
  message(sprintf("Filtered %d proteins out of %d total.", nrow(filtered_df), nrow(protein_df)))
  return(filtered_df)
}




# Function for running/choosing between the filters (load/run once)
# -------------------------------
# Wrapper: choose GO filter interactively
# -------------------------------
run_go_filter <- function(protein_df) {
  
  # List of functions with descriptions
  filters <- list(
    list(name = "filter_proteins_by_go", 
         desc = "Filter by GO IDs"),
    list(name = "filter_proteins_by_go_names", 
         desc = "Filter by GO names (contains/fuzzy)"),
    list(name = "filter_proteins_by_go_names_strict", 
         desc = "Filter by GO names (exact match)"),
    list(name = "filter_proteins_by_go_combined", 
         desc = "Filter by GO IDs and GO names (contains/fuzzy)"),
    list(name = "filter_proteins_by_go_combined_strict", 
         desc = "Filter by GO IDs and GO names (exact match)")
  )
  
  # Print numbered list
  cat("Choose a GO filter function to run:\n")
  for (i in seq_along(filters)) {
    cat(sprintf("%d: %s - %s\n", i, filters[[i]]$name, filters[[i]]$desc))
  }
  
  # Prompt user for selection
  selection <- readline(prompt = "Enter the number of the function to run: ")
  
  # Validate input
  if (!grepl("^[1-5]$", selection)) {
    stop("Invalid selection. Please enter a number from 1 to 5.")
  }
  
  selection <- as.integer(selection)
  func_name <- filters[[selection]]$name
  
  # Confirm
  cat(sprintf("Running function: %s\n", func_name))
  
  # Call the selected function dynamically
  result <- do.call(func_name, list(protein_df))
  
  return(result)
}

# -------------------------------
# Example usage:
# filtered_proteins <- run_go_filter(protein_data_with_go)



# ---------------------------------------------------------------------
# Function: filter_numeric_protein_data
# Purpose: Filter a numeric protein expression dataset by:
#          - GeneSymbols
#          - Protein sample columns
#          - Top N expressions (per gene or per sample)
#          - Expression value thresholds (above, below, or equal to)
#          - Combinations of all filters
# ---------------------------------------------------------------------

filter_numeric_protein_data <- function(
  data, 
  gene_symbols = NULL,          # Vector of GeneSymbols to keep (default NULL = keep all)
  protein_samples = NULL,       # Vector of column names to keep (default NULL = keep all)
  top_n_genes = NULL,           # Number of top-expressing genes to keep (per column)
  expression_threshold = NULL,  # Vector: c("operator", value), e.g., c(">", 2)
  combine_logic = "AND"         # "AND" or "OR" for combining filters
) {
  # Step 0: Validate input
  if (!is.data.frame(data)) stop("`data` must be a data frame.")
  if (!all(sapply(data, is.numeric))) stop("All columns in `data` must be numeric (row names = genes).")
  
  filtered_data <- data
  
  # Step 1: Filter by GeneSymbols
  if (!is.null(gene_symbols)) {
    keep_gene <- rownames(filtered_data) %in% gene_symbols
    if (combine_logic == "AND") filtered_data <- filtered_data[keep_gene, , drop=FALSE]
  }
  
  # Step 2: Filter by protein samples (columns)
  if (!is.null(protein_samples)) {
    missing_cols <- setdiff(protein_samples, colnames(filtered_data))
    if (length(missing_cols) > 0) warning("Some protein samples not found: ", paste(missing_cols, collapse=", "))
    keep_cols <- intersect(protein_samples, colnames(filtered_data))
    filtered_data <- filtered_data[, keep_cols, drop=FALSE]
  }
  
  # Step 3: Filter by expression threshold
  if (!is.null(expression_threshold)) {
    operator <- expression_threshold[1]
    value <- as.numeric(expression_threshold[2])
    if (!(operator %in% c(">", ">=", "<", "<=", "=="))) stop("Operator must be one of >, >=, <, <=, ==")
    
    expr_filter <- switch(operator,
                          ">"  = filtered_data > value,
                          ">=" = filtered_data >= value,
                          "<"  = filtered_data < value,
                          "<=" = filtered_data <= value,
                          "==" = filtered_data == value)
    
    # Keep rows that satisfy the threshold (any column)
    keep_rows <- rowSums(expr_filter) > 0
    filtered_data <- filtered_data[keep_rows, , drop=FALSE]
  }
  
  # Step 4: Filter top N genes by mean expression (optional)
  if (!is.null(top_n_genes)) {
    gene_means <- rowMeans(filtered_data, na.rm = TRUE)
    top_genes <- names(sort(gene_means, decreasing = TRUE))[1:min(top_n_genes, nrow(filtered_data))]
    filtered_data <- filtered_data[top_genes, , drop=FALSE]
  }
  
  # Step 5: Return filtered dataset
  return(filtered_data)
}
```