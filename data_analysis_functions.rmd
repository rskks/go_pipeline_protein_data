```{r}
# Heatmap Function
# ---------------------------------------------------------------------
# Function: plot_interactive_protein_heatmap
# Purpose: Create interactive heatmap for protein expression data
# ---------------------------------------------------------------------
plot_interactive_protein_heatmap <- function(
  data, 
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  zero_color = "lightgray",
  low_color = "blue",
  mid_color = "yellow",
  high_color = "red",
  min_value = 0,
  mid_value = 5,
  max_value = 10,
  tooltip_precision = 3
) {
  # Validate input
  if (!is.data.frame(data)) stop("`data` must be a dataframe.")
  if (!all(sapply(data, is.numeric))) stop("All columns in `data` must be numeric.")
  if (is.null(rownames(data))) stop("Dataframe must have rownames representing genes.")

  # Clip values to min/max
  data_clipped <- pmin(pmax(as.matrix(data), min_value), max_value)

  # Convert to long format
  df_long <- data_clipped %>%
    as.data.frame() %>%
    mutate(Gene = rownames(data_clipped)) %>%
    tidyr::pivot_longer(
      cols = -Gene,
      names_to = "Sample",
      values_to = "Expression"
    ) %>%
    mutate(text = paste0("Gene: ", Gene,
                         "\nSample: ", Sample,
                         "\nExpression: ", round(Expression, tooltip_precision)))

  # Cluster rows
  if (cluster_rows) {
    row_order <- hclust(dist(data_clipped))$order
    df_long$Gene <- factor(df_long$Gene, levels = rownames(data_clipped)[row_order])
  } else {
    df_long$Gene <- factor(df_long$Gene, levels = rownames(data_clipped))
  }

  # Cluster columns
  if (cluster_columns) {
    col_order <- hclust(dist(t(data_clipped)))$order
    df_long$Sample <- factor(df_long$Sample, levels = colnames(data_clipped)[col_order])
  } else {
    df_long$Sample <- factor(df_long$Sample, levels = colnames(data_clipped))
  }

  # Plot with blue → yellow → red gradient
  p <- ggplot(df_long, aes(x = Sample, y = Gene, fill = Expression, text = text)) +
    geom_tile(color = "gray90") +
    scale_fill_gradientn(
      colors = c(low_color, mid_color, high_color),
      values = scales::rescale(c(min_value, mid_value, max_value)),
      na.value = zero_color
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          axis.text.y = element_text(size = 8),
          panel.grid = element_blank())

  # Convert to interactive plotly
  ggplotly(p, tooltip = "text")
}



# VennDiagram/upset plot Function
# ---------------------------------------------------------------------
# Function: plot_protein_venn
# Purpose: Create a Venn or UpSet diagram of protein presence across samples
# ---------------------------------------------------------------------
plot_protein_venn <- function(data) {
  # Step 0: Validate input
  if (!is.data.frame(data)) stop("`data` must be a dataframe.")
  if (nrow(data) == 0 || ncol(data) == 0) stop("`data` must have at least 1 row and 1 column.")
  
  # Step 1: Prompt user to select columns
  cat("Columns available in your dataset:\n")
  print(colnames(data))
  
  user_input <- readline(prompt = "Enter column names to include in Venn diagram (comma-separated): ")
  selected_cols <- str_trim(unlist(strsplit(user_input, ",")))
  
  if (length(selected_cols) == 0) stop("No columns selected.")
  if (!all(selected_cols %in% colnames(data))) stop("Some selected columns do not exist in the dataframe.")
  
  # Step 2: Create list of sets (genes with non-zero or non-NA expression)
  venn_list <- lapply(selected_cols, function(col) {
    genes_present <- rownames(data)[!is.na(data[[col]]) & data[[col]] != 0]
    return(genes_present)
  })
  names(venn_list) <- selected_cols
  
  # Step 3: Plot Venn or UpSet depending on number of sets
  num_sets <- length(venn_list)
  if (num_sets < 2) {
    stop("At least 2 columns must be selected for a Venn diagram.")
  } else if (num_sets > 5) {
    message("More than 5 sets selected. Will plot as an UpSet diagram instead of traditional Venn.")
    p <- ggVennDiagram(venn_list, force_upset = TRUE, label_color='white')
    return(p)
  } else {
    p <- ggVennDiagram(venn_list, label_color='white')
    return(p)
  }
}
```